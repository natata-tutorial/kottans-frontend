git init
git status

git add index.html
git add .

git commit -m "commit comment"
git commit -a -m "comment"
git config --list

git remote add origin URL
git push origin HEAD

Перемещение по дереву коммитов
git checkout main^ //Перемещение на один коммит назад ^, main^ означает "первый родитель ветки main"
	git checkout main^2 - второй родитель мерджевого коммита

git checkout HEAD~4 //Перемещение на несколько коммитов назад ~<num>

Перемещение ветки (branch forcing)
git branch -f main HEAD~3 // относительная ссылка, Переместит (принудительно) ветку main на три родителя назад от HEAD.

git checkout HEAD~^2~2


Отмена изменений

git clean -f             #untracked
git restore .            #modified
git restore --staged .   #staged
git reset                #staged
git reset HEAD~          #commited

git reset //отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было. На локальных ветках!!!
	git reset HEAD~1

git revert // Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать git revert. Появился новый коммит. Дело в том, что новый коммит C2' просто содержит изменения, полностью противоположные тем, что сделаны в коммите C2. После revert можно сделать push и поделиться изменениями с остальными.
	git revert HEAD


Перемещение изменений
git cherry-pick <Commit1> <Commit2> <...> //способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD). когда точно известно, какие коммиты нужны (и известны их точные хеши)

Git Interactive Rebase
опция -i - Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.
	git rebase -i HEAD~4

	git rebase main bugFix	


Таг
git tag v1 C1 //назвали тег v1 и заставили его ссылаться на C1 явным образом. Если конкретный коммит не указан, гит пометит тегом HEAD

git describe <ref> //Где ref — это что-либо, что указывает на конкретный коммит. Если не указать ref, то git будет считать, что указано текущее положение (HEAD).	

<tag>_<numCommits>_g<hash>

Где tag – это ближайший тег в истории изменений, numCommits – это на сколько далеко мы от этого тега, а hash – это хеш коммита, который описывается.


Git Fetch

связывается с указанным удалённым репозиторием и забирает все те данные проекта, которых у вас ещё нет, при этом...
у вас должны появиться ссылки на все ветки из этого удалённого репозитория (например, o/main)
Фактически, git fetch синхронизирует локальное представление удалённых репозиториев с тем, что является актуальным на текущий момент времени.

Важно отметить, что команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент.

git fetch

git cherry-pick o/main
git rebase o/main
git merge o/main


Процедура скачивания (fetching) изменений с удалённой ветки и объединения (merging) настолько частая и распространённая, что git предоставляет вместо двух команд - одну! Эта команда - git pull.


	git fetch
	git rebase origin/main
	git push

		git pull
		git push

	git fetch
	git merge origin/main
	git push

		git pull --rebase
		git push


Мы выполним checkout для новой ветки foo и укажем ей, чтобы она отслеживала main с удалённого репозитория.

	git checkout -b foo original/main 
	git pull

git branch -u o/main foo // Другой способ указать ветке отслеживать удалённую ветку — это просто использовать команду git branch -u.
вы укажете ветке foo следить за o/main. А если вы ещё при этом находитесь на ветке foo, то её можно не указывать:

git branch -u o/main

	git branch -u o/main foo
	git commit
	git push

git push <удалённый_репозиторий> <целевая_ветка>

	git push origin main

дословный перевод с английского будет таким:

Перейди в ветку с именем "main" в моём локальном репозитории, возьми все коммиты и затем перейди на ветку "main" на удалённом репозитории "origin.". На эту удалённую ветку скопируй все отсутствующие коммиты, которые есть у меня, и скажи, когда ты закончишь.

git push origin <источник>:<получатель>

	git push origin foo^:main //git видит в foo^ не что иное, как местоположение, закачивает все коммиты, которые не присутствуют на удалённом репозитории, и затем обновляет получателя.

	git push origin main:newBranch

git fetch origin foo

Git отправится в ветку foo на удалённом репозитории, соберёт с собой все коммиты, которые не присутствуют локально, и затем поместит их в локальную ветку под названием o/foo. мы скачиваем только коммиты с ветки foo и помещаем их в o/foo.

	 git fetch origin foo~1:bar
Теперь у нас <источник> - это место на удалённом репозитории, а <получатель> - место в локальном репозитории, в который следует помещать коммиты. Аргументы в точности до наоборот повторяют git push, и немудрено, ведь теперь мы переносим данные в обратном направлении!


git push origin :foo //мы удалили ветку foo в удаленном репозитории, попытавшить протолкнуть(git push) в неё "ничего"

git fetch origin :bar //мы попытаемся притянуть изменения(git fetch) из "ничего" к нам в локальный репозиторий, то это создаст у нас новую ветку

Как мы помним, git pull сначала выполняет git fetch, а следом сразу git merge с той веткой, в которую притянулись обновления командой fetch. Другими словами, это все равно, что выполнить git fetch с теми же аргументами, которые вы указали для pull, а затем выполнить git merge с веткой, указанной в аргументе <приемник> команды pull.

git pull origin bar~1:bugFix то же, что:
git fetch origin bar~1:bugFix; git merge bugFix

git pull origin main:foo //Мы создали новую ветку foo в локальном репозитории, скачали на неё изменения с ветки main удаленного репозитория, а затем слили эту ветку с веткой bar, на которой мы находились!


git remote -v
git remote show origin

git branch -r // read only branches
git config --global credential-helper cache